import pygame
import multiprocessing as mp
import queue
import math
import time
import numpy as np
from mpi4py import MPI
import unittest


GET_BOX
request: ('GET_BOX', id)
reply: ('GET_BOX', box)

GET_SIZE
request: ('GET_SIZE', id)
reply: ('GET_SIZE', n_workers)

GET_PUCK
request: ('GET_PUCK', n, id)
reply: ('GET_PUCK', puck)

SET_NAME
request: ('SET_NAME', name, secret, id)
reply: ('SET_NAME', name)

SET_ACCELERATION
request: ('SET_ACCELERATION', a, secret, id)
reply: ('SET_ACCELERATION', a)



V_MIN =  10.0
V_MAX =  42.0
A_MAX = 100.0

class Box:

    def __str__(self):
        return f"Box(xmin={self.xmin}, xmax={self.xmax}, "\
                   f"ymin={self.ymin}, ymax={self.ymax})"

    def get_x_limits(self):
        return (self.xmin, self.xmax)

    def get_y_limits(self):
        return (self.ymin, self.ymax)

class Puck:

    RADIUS = 1.0

    def __str__(self):
        return f"Puck(Id={self.id}, Alive={self.alive}, "\
               f"s={self.s}, v={self.v}, a={self.a}"

    def is_alive(self):
        return self.alive

    def get_id(self):
        return self.id

    def get_time(self):
        return self.t

    def get_position(self):
        return self.s

    def get_velocity(self):
        return self.v

    def get_acceleration(self):
        return self.a

    def get_name(self):
        return self.name

    def get_fuel(self):
        return self.fuel

    def get_points(self):
        return self.points
        
def worker_arda(id, secret, q_request, q_reply):
    #Namen setzen
    q_request.put(('SET_NAME', 'Arda', secret, id))
    reply_x = q_reply.get()
    #Abfrage der Puckanzahl
    q_request.put(('GET_SIZE', id))
    reply_y = q_reply.get()
    N = reply_y[1]
    for n in range(0, N): 
        q_request.put(('GET_PUCK', n, id))
        reply_x = q_reply.get()
        puck_y = reply_x[1]
        if puck_y.get_id() == id:
            meine_nummer = n
            break

    while True:
        l1 =[]
        l1.clear()
        q_request.put(('GET_PUCK', meine_nummer, id))
        mein_puck = q_reply.get()[1]
        meine_position = mein_puck.get_position()
        meine_geschwindikeit = mein_puck.get_velocity()
        meine_beschleunigung = mein_puck.get_acceleration()
        for i in range(0, N):
            q_request.put(('GET_PUCK', i, id))
            anderer_puck = q_reply.get()[1]
            andere_position = anderer_puck.get_position()
            andere_geschwindigkeit = anderer_puck.get_velocity()
            t = - np.dot((andere_position - meine_position) , (andere_geschwindigkeit - meine_geschwindigkeit))/ np.dot((andere_geschwindigkeit - meine_geschwindigkeit), (andere_geschwindigkeit - meine_geschwindigkeit)))
            l1.append(t)
            
            
            
            
            if mein_puck.is_alive():
                return True
        
    
    



















    
    #Boxgrenzen anfragen
    q_request.put(('GET BOX', id))
    box_grenzen = q_reply.get(('GET_BOX', box))
    box_x = box.get_x_limits()
    xmin = x_coordinate[0]
    xmax = x_coordinate[1]
    box_y = box.get_y_limits()
    ymin = y_coordinate[0]
    ymax = y_coordinate[1]
    
    q_request.put(('SET_ACCELERATION', a, secret, id)):
    reply_a = q_reply.get()
    a_vector = reply_a[1]
    if a_vector is None:
        raise Error

    if position[0] < x_limits[0] + 1:
        acceleration[0] =   A_MAX
    elif position[0] > x_limits[1] - 1:
        acceleration[0] = - A_MAX
    
        

#velocity        
#accileration
#important pucks
#worker endless loop
#prioritization


r = route
d = distance
#d = r2-r1
v = velocity
a = acceleration
t = time
#r1_vector = numpy.array(r1 +  v1 * t)
#r2_vector = numpy.array(r2 +  v2 * t)
betrag_v = math.sqrt(x**2 + y**2)
v_puck:
reply = q_reply.get_velocity()

r1 = np.array([1, 1])
r2 = np.array([0,0])
d**2(r1, r2) = (r2-r1 + v2-v1 * t)**2
#(np.diff(d**2 (r1, r2)) = 0)
t= - ((andere_position - meine_position) * (andere_geschwindigkeit - meine_geschwindigkeit)/ (andere_geschwindigkeit - meine_geschwindigkeit)**2)
if dot(r1_vector, r2_vector) == 0:
    return True
(andere_geschwindigkeit-meine_geschwindigkeit) = a * (t2-t1)

v_puck


    
if puck is is_alive():
    return True
else:
    return False
get_id()
get_time()
get_position()
get_velocity()
get_acceleration()
get_fuel()
get_name()
get_points()
#Radius bei Reflexion mitber√ºcksichtigen


if v_puck in range(V_MIN, V_MAX):
    return True and q_reply.get_velocity()
else:
    return False

for vector_distance


#nicht existieren;  puck = None

    

    
        
#s = MPI.Status()
#while True
#get_position

unittest.main()
